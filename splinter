#!/bin/bash
version="0.4-beta"
release_date="20200912"
config_dir=""
my_name="$(basename "${0}")"
start_time=$(date +%s)

ansible_force_roles_update=''

python_provider="conda"

pip_dependecies="
ansible
wheel
passlib
"
pip_show_grep_filter='Version'  # 'Name\|Version\|Location' - it's a grep filter

conda_package_name="splinter-conda.tar.gz"
conda_package_version="v0.1"
conda_package_url="https://github.com/marcomc/splinter-conda/releases/download/${conda_package_version}/${conda_package_name}"

desired_ansible_version='2.9.13'
desired_passlib_version='1.7.2'
desired_python_version='3.8.5'
desired_wheel_version='0.35.1'

homebrew_installer_url='https://raw.githubusercontent.com/Homebrew/install/master/install.sh'

pause_seconds='3'
staff_guid='20'

splinter_archive_url="https://github.com/marcomc/splinter/archive/master.zip"
splinter_tools_url="https://github.com/marcomc/splinter-tools/archive/master.zip"

function _exec {
  "$@" || { _echo "Failed during: ${*}" 'e'; exit 1; }
}

function _echo {
  purple="\e[35m"
  red="\e[31m"
  green="\e[32m"
  cyan="\e[36m"
  white="\e[39m"
  yellow="\e[33m"
  message_type=""
  output_device="/dev/stdin"
  case ${2} in
    a|action)
      colour="${cyan}" #green
      tag='ACTION.'
    ;;
    w|warning)
      colour="${yellow}"
      tag='WARNING'
      message_type="warning"
      output_device="/dev/stderr"
      ;;
    e|error)
      colour="${red}"
      tag='ERROR..'
      message_type="error"
      output_device="/dev/stderr"
      ;;
    r|remark)
      colour="${purple}" #green
      tag='#######'
    ;;
    i|info|*)
      message_type="info"
      colour="${green}" #green
      tag='INFO...'
    ;;
  esac
  if [[ "${verbose}" == "yes" ]] || [[ "${message_type}" != "info" ]]; then
    if [[ "${quiet}" == "no" ]] || [[ "${message_type}" == "error" ]] || [[ "${message_type}" == "warning" ]]; then
      printf "${colour}[${tag}] ${white}%s\n" "${1}" > "${output_device}"
    fi
  fi
}

function show_version {
  echo "Splinter ${version} ${release_date}"
}

function show_title {
  cat << 'EOF'
   _______  _____         _____ __   _ _______ _______  ______
   |______ |_____] |        |   | \  |    |    |______ |_____/
   ______| |       |_____ __|__ |  \_|    |    |______ |    \_
        2020 (c) MarcMC - github.com/marcomc/splinter
An opinionated provisioning tool for macOS automated with Ansible

EOF
}

function show_usage {
  printf "usage: %s [option] action [object] [settings]\n" "${my_name}"
  printf "options: \n"
  printf "       -e|--env conda|pyenv     List available profiles\n"
  printf "       --help                   Print help\n"
  printf "       --version                Print Splinter version and release date\n"
  printf "actions: \n"
  printf "       list profiles            List available profiles\n"
  printf "       provision [settings]     Provision the host\n"
  printf "       update <object>          Update the object\n"
  printf "\n"
  printf "obejcts: \n"
  printf "       conda                    Reinstall the most recent Miniconda Python environment available for splinter\n"
  printf "       pyenv                    Reinstall Pyenv Python environment\n"
  printf "       roles|galaxy|ansible     Force update all the Ansible Galaxy roles\n"
  printf "       tools                    Update the splinter tools\n"
  printf "       deps|dependencies        Update all the dependencies (Python envs and  Ansible Galaxy role)\n"
  printf "       self|auto|splinter       Update Splinter itself (but not the tools or dependencies)\n"
  printf "\n"
  printf "settings: \n"
  printf "       -c file                  Specify a custom configuration file\n"
  printf "       -b base_profile_name     Specify the the BASE profile to be used (default: 'default')\n"
  printf "       -r role_profile_name     Specify the the ROLE profile to be used\n"
  printf "       -u username              New user username (all lowercase  without spaces)\n"
  printf "       -f 'Full Name'           New user full name (quoted if has blank spaces)\n"
  printf "       -p 'cleartext password'  New user's password in cleartext (quoted if has blank spaces)\n"
  printf "       -h Computer-Name         Computer host name no blank spaces allowed\n"
  printf "       -q                       Suppress all non-Ansible output (except errors and warnings), is overriden with '-v'\n"
  printf "       -v                       Produce verbose output\n"
  printf "\n"
  printf "Create your own profiles in the '%s' directory.\n" "${profiles_path}"
  printf "\n"
  return 0
}

function print_execution_time {
  start_seconds="${1}"
  end_seconds=$(date +%s)
  total_seconds=$(( end_seconds - start_seconds ))
  total_minutes=$(( total_seconds / 60 ))

  if [[ ${total_minutes} -gt 0 ]]; then
    total="${total_minutes} minutes"
  else
    total="${total_seconds} seconds"
  fi
  _echo "Execution time was ${total}" 'r'
}

function set_app_directories {
  if [[ -z "${SPLINTER_CONFIG_DIR}" ]]; then
    if [[ -z "${config_dir}" ]]; then
      # assumes the directory that contains `splinter` is the Splinter directory
      config_dir="$(realpath "$(dirname "${0}")")"
    fi
    export SPLINTER_CONFIG_DIR="${config_dir}"
  else
    # makes sure that `config_dir` is assigned
    config_dir="${SPLINTER_CONFIG_DIR}"
  fi

  files_path="${SPLINTER_CONFIG_DIR}/files"
  tools_path="${SPLINTER_CONFIG_DIR}/tools"
  profiles_path="${SPLINTER_CONFIG_DIR}/profiles"
  ansible_dir="${SPLINTER_CONFIG_DIR}/ansible"
  pyenv_dir="${SPLINTER_CONFIG_DIR}/pyenv"
  conda_path="${SPLINTER_CONFIG_DIR}/conda"
  pip_config_file="${SPLINTER_CONFIG_DIR}/pip.conf"

  ansible_roles="${ansible_dir}/roles"
  ansible_config="${ansible_dir}/ansible.cfg"
  ansible_inventory="${ansible_dir}/inventory"
  ansible_playbook="${ansible_dir}/playbook.yml"
  ansible_requirements="${ansible_dir}/requirements.yml"
}

function update_splinter {
  _echo "Updating splinter" 'a'
  splinter_archive="${my_name}.zip"
  temp_dir=$(mktemp -d)

  _echo "Downloading Splinter into '${temp_dir}/${splinter_archive}'" 'a'
  _exec "curl" "-fsSL" "${splinter_archive_url}" "-o" "${temp_dir}/${splinter_archive}"

  _echo "Decompressing Splinter archive into '${temp_dir}'" 'a'
  _exec "unzip" "-qq" "${temp_dir}/${splinter_archive}" "-d" "${temp_dir}"
  ls "${temp_dir}"

  _echo "Installing Splinter files to '${config_dir}'" 'a'
  _exec "rsync" "-rlWuv" "${temp_dir}"/*/* "${config_dir}"

  _echo "Removing temporary files" 'a'
  _exec "rm" "-rf" "${temp_dir}"

  _echo "Update successful!" 'r'
}

function update_tools {
  _echo "Updating Splinter tools" 'a'
  splinter_tools_archive="${my_name}-tools.zip"
  temp_dir=$(mktemp -d)

  _echo "Downloading Splinter tools into '${temp_dir}/${splinter_tools_archive}'" 'a'
  _exec "curl" "-fsSL" "${splinter_tools_url}" "-o" "${temp_dir}/${splinter_tools_archive}"

  _echo "Decompressing Splinter tools into '${temp_dir}'" 'a'
  _exec "unzip" "-qq" "${temp_dir}/${splinter_tools_archive}" "-d" "${temp_dir}"
  ls "${temp_dir}"

  _echo "Installing Splinter tools to '${tools_path}'" 'a'
  _exec "rsync" "-rlWuv" "${temp_dir}"/*/* "${tools_path}"

  _echo "Removing temporary files" 'a'
  _exec "rm" "-rf" "${temp_dir}"

  _echo "Tools updated successfully!" 'r'
}

function check_install_path_permissions {
  current_path=$(pwd -P)
  third_level_dir=$(echo "${current_path}" | cut -d'/' -f-4)
  dir_stats=$(stat -f '%N %g %p' "${third_level_dir}")
  read -ra DIR_STATS <<< "${dir_stats}"
  dir_name="${DIR_STATS[0]}"
  dir_group_id="${DIR_STATS[1]}"
  dir_pemissions="${DIR_STATS[2]:(-3)}"
  dir_group_pemissions="${DIR_STATS[2]:(-2):1}"

  if [[ "${current_path}" == "${HOME}"* ]]; then
    _echo 'You are running this script within your home directory' 'w'
    _echo 'Ansible might fail if your home directories are protected' 'w'
    _echo "(not allowing group memebers to 'read' AND 'exec' them)" 'w'
    _echo "Checking the permissions on the containing dir" 'a'
    _echo "DIR_NAME: ${dir_name}"
    _echo "dir_group_id: ${dir_group_id}"
    _echo "DIR_PEMISSIONS: ${dir_pemissions}"
    if [[ "${staff_guid}" != "${dir_group_id}" ]]; then
      _echo "The '${dir_name}' group is not 'staff(${staff_guid})'" 'w'
    elif [[ "${dir_group_pemissions}" -lt "5" || "${dir_group_pemissions}" -eq "6" ]]; then
      _echo "'${dir_name}' does NOT allow the 'staff' group to 'read' AND 'exec'" 'w'
      _echo "(this might lead to issues during the execution of some Ansible tasks)" 'w'
      _echo "Adding POSIX 'g+rx' permissions to ${third_level_dir}" 'a'
      _exec "chmod" "g+rx" "${third_level_dir}"
      export ORIGINAL_DIR_PEMISSIONS="${dir_pemissions}"
      export THIRD_LEVEL_DIR="${third_level_dir}"
    fi
    if [[ "${quiet}" == "no" ]]; then
      _echo "Pausing for ${pause_seconds} seconds for you to read the above message..." 'a'
      printf ">>>>>>>>> "
      for ((i=1; i<=pause_seconds; i++)); do
        # running the countdown before resuming operations
        printf "..%s" "${i}"
        sleep 1
      done
      printf "\n" # add newline after the countdown
    fi
  fi
}

function restore_path_permissions {
  if [ -n "${ORIGINAL_DIR_PEMISSIONS}" ] && [ -n "${THIRD_LEVEL_DIR}" ]; then
    _echo "Restoring original permissions '${ORIGINAL_DIR_PEMISSIONS}' to the directory '${THIRD_LEVEL_DIR}'" 'a'
    chmod "${ORIGINAL_DIR_PEMISSIONS}" "${THIRD_LEVEL_DIR}"
  fi
}

function profile_is_available {
  if [ -z "${1}" ]; then
    # if the paramater is empty just keep going
    # ansible will only load default configs
    _echo "No profile name has been provides. Will use the values set in Ansible"
    exit 1
  elif [ ! -d "${profiles_path}/${1}" ]; then
    _echo "The profile '${1}' does not exist" 'e'
    exit 1
  fi
}

function enable_passwordless_sudo {
  sudo_stdin=''
  if sudo -n true 2>/dev/null; then
    _echo "Passwordless sudo is seems to be already available"
  else
    if [ -n "${ANSIBLE_BECOME_PASS}" ]; then
      sudo_stdin='--stdin'
    fi
    # Enable passwordless sudo for the provisioning
    _echo "Enabling passwordless sudo for the provisioning" 'a'
    echo "${ANSIBLE_BECOME_PASS}" | sudo "${sudo_stdin}" sed -i -e "s/^%admin (.*)ALL.*/%admin ALL=(ALL) NOPASSWD: ALL/" /etc/sudoers >/dev/null 2>&1
  fi
}

function disable_passwordless_sudo {
  if sudo -n true 2>/dev/null; then
    # Enable passwordless sudo for the provisioning
    _echo "Disabling passwordless sudo after the provisioning" 'a'
    sudo sed -i -e "s/^%admin (.*)ALL.*/%admin ALL=(ALL) ALL/" /etc/sudoers
  else
    _echo "Passwordless sudo is disabled"
  fi
}

function install_pip_dependencies {
  for pip_dependecy in ${pip_dependecies}; do
    if ! pip show "${pip_dependecy}" >/dev/null 2>&1; then
      _echo "${pip_dependecy} not installed" w
      eval "install_pip_${pip_dependecy}"
    else
      dep_version=$(pip show "${pip_dependecy}" | grep "${pip_show_grep_filter}")
      _echo "${pip_dependecy} ${dep_version} is installed "
    fi
  done
}

function install_brew {
  if ! command -v "brew" >/dev/null 2>&1; then
    _echo "Installing Homebrew" 'a'
    /bin/bash -c "$(curl -fsSL ${homebrew_installer_url})" < /dev/null
  else
    tool_version=$(command -v "brew")
    _echo "Homebrew ${tool_version} is installed"
  fi

}

function install_conda {
  conda_package_path="${files_path}/${conda_package_name}"
  if [[ "${reinstall_conda}" == "yes" ]];then
    if [[ -f "${conda_package_path}" ]]; then
      _echo "Removing old Miniconda Python package '${conda_package_path}'" 'a'
      _exec "rm" "${conda_package_path}"
    fi
    if [[ -d "${conda_path}" ]]; then
      _echo "Removing old Miniconda Python directory '${conda_path}'" 'a'
      _exec "rm" "-rf" "${conda_path}"
    fi
  fi
  if [[ ! -d "${conda_path}/bin" ]];then
    if [[ ! -f "${conda_package_path}" ]];then
      _echo "Downloading Miniconda Python package to '${conda_package_path}'" 'a'
      _exec "curl" "-fsSL" "${conda_package_url}" "-o" "${conda_package_path}"
    fi
    _echo "Unpacking Miniconda Python package to '${conda_path}' directory" 'a'
    _exec "mkdir" "-p" "${conda_path}"
    _exec "tar" "-xzf" "${conda_package_path}" "-C" "${conda_path}"
  else
    _echo "Miniconda Python package is already installed in '${conda_path}' directory" 'i'
  fi
}

function activate_conda {
  _echo "USING PROJECT'S OWN MINICONDA PYTHON VERSION" 'r'

  # Actual Conda activation
  python_root="${conda_path}"
  export _CONDA_ROOT="${conda_path}"
  export CONDA_PREFIX="${_CONDA_ROOT}"
  export PATH="${_CONDA_ROOT}/bin:$PATH"

  _echo "Cleanup prefixes from in the active environment"
  _exec "conda-unpack"

  python_version="$(python --version 2>&1)"
  _echo "${python_version} is installed"

  # Fix issues with SSL Certificates
  cert_path=$(python -m certifi)
  export SSL_CERT_FILE="${cert_path}"
  export REQUESTS_CA_BUNDLE="${cert_path}"
  _echo "SSL_CERT_FILE: ${cert_path}"
  _echo "REQUESTS_CA_BUNDLE: ${cert_path}"

}

function activate_pyenv {
  _echo "USING PROJECT'S OWN PYENV PYTHON VERSION" 'r'
  export PYENV_ROOT="${pyenv_dir}"
  export PATH="${PYENV_ROOT}/bin:${PATH}"
  export PYENV_VERSION="${desired_python_version}"
  python_root="${pyenv_dir}"
  _echo "PYENV_ROOT: ${PYENV_ROOT}"
  _echo "PYTHON_VERSION: $(pyenv version)"
}

function update_brew {
  _echo "Updating Homebrew" 'a'
  _exec "brew" "update"
}

function install_pyenv {
  if ! command -v "pyenv" >/dev/null 2>&1; then
    _echo "Installing Pyenv" 'a'
    # install pyenv with homebrew
    eval update_brew
    _exec "brew" "install" "pyenv"
  else
    tool_version=$(command -v "pyenv")
    _echo "Pyenv ${tool_version} is installed"
  fi
}

function install_pip_ansible {
  _echo "PIP - Installing Ansible ${desired_ansible_version}" 'a'
  _exec "pip" "install" "ansible==${desired_ansible_version}"
  # pip show ansible | grep "${pip_show_grep_filter}"
}

function install_pip_wheel {
  _echo "PIP - Installing Wheel ${desired_wheel_version}" 'a'
  _exec "pip" "install" "wheel==${desired_wheel_version}"
  # pip show "wheel"  | grep "${pip_show_grep_filter}"
}

function install_pip_passlib {
  _echo "PIP - Installing passlib ${desired_passlib_version}" 'a'
  _exec "pip" "install" "passlib==${desired_passlib_version}"
  # pip show "passlib" | grep "${pip_show_grep_filter}"
}

function install_pyenv_python {
  if [[ "${reinstall_pyenv}" == "yes" ]]; then
    if [[ -d "${pyenv_dir}" ]]; then
      _echo "Removing old Pyenv Python directory '${pyenv_dir}'" 'a'
      _exec "rm" "-rf" "${pyenv_dir}"
    fi
  fi
  if ! pyenv versions | grep "${desired_python_version}" >/dev/null 2>&1; then
    # •	install python3 with pyenv
    _echo "Installing Pyenv Python ${desired_python_version}" 'a'
    _exec "pyenv" "install" "${desired_python_version}"
    _exec "ln" "-fs" "shims" "${pyenv_dir}/bin"
    _echo "Rehashing Pyenv Python shims ${desired_python_version}" 'a'
    _exec "pyenv" "rehash"
  else
    _echo "Pyenv Python ${desired_python_version} is already installed"
  fi
}

function upgrade_pip {
    _echo "Upgrading PIP to the latest version" 'a'
    _exec "pip" "install" "--upgrade" "pip"
}

function install_ansible {
  if ! command -v 'ansible' >/dev/null 2>&1; then
    _echo "Ansible not installed" w
    eval install_pip_ansible
  else
    _echo "Ansible is already installed"
    _exec "ansible" "--version"
  fi
}

function install_ansible_galaxy_roles {

  if [ "${verbose}" == "yes" ];then
    dev_output="/dev/stdout"
  else
    dev_output="/dev/null"
  fi
  ansible_galaxy_command="ansible-galaxy role install -r '${ansible_requirements}' -p '${ansible_roles}' ${ansible_force_roles_update}"
  _echo "Installing Ansible Galaxy roles" 'a'
  eval "${ansible_galaxy_command}" 1> "${dev_output}"
}

function run_ansible_playbook {
  _echo "Running Ansible provisioning" 'a'
  export ANSIBLE_CONFIG="${ansible_config}"
  _echo "ANSIBLE_CONFIG: ${ANSIBLE_CONFIG}"
  export ANSIBLE_ROLES_PATH="${ansible_roles}"
  # this is not wrapped with `execute` because if an error occur during Ansible execution we want the script to keep going and run the cleanup tasks
  ansible-playbook "${ansible_playbook}" -i "${ansible_inventory}"
}

function ask_for_ansible_sudo_password {
  # temporarely store the password in cleartext in the environment
  # so it can be used by Ansible throughout the whole execution
  if [ -z "${ANSIBLE_BECOME_PASS}" ]; then
        _echo "Requesting the admin password to be used for 'sudo' throughout the deployment process" 'a'
        read -r -p ">>>>>>>>> Insert the current user password: " -s ansible_become_pass
        export ANSIBLE_BECOME_PASS="${ansible_become_pass}"
        printf "\n"
  else
        _echo "'ANSIBLE_BECOME_PASS' is already set"
  fi
}

function setup_python {
  if [ "${python_provider}" == "pyenv" ];then
    eval install_pyenv
    eval activate_pyenv
    eval install_pyenv_python
  elif [ "${python_provider}" == "conda" ];then
    eval install_conda
    eval activate_conda
  else
    _echo "Unknow python provider '${python_provider}'" 'e'
    exit 1
  fi
  export PYTHON_PROVIDER="${python_provider}"
  _echo "PYTHON_PROVIDER: ${PYTHON_PROVIDER}"
  export PYTHON_ROOT="${python_root}"
  _echo "PYTHON_ROOT: ${PYTHON_ROOT}"
  export PIP_CONFIG_FILE="${pip_config_file}"
  _echo "PIP_CONFIG_FILE: ${PIP_CONFIG_FILE}"
}

function cleanup_tasks {
  eval restore_path_permissions
  eval disable_passwordless_sudo
}

function install_dependencies {
  eval install_brew
  eval setup_python
  if [[ "${reinstall_conda}" == "yes" ]] || [[ "${reinstall_pyenv}" == yes ]]; then
    eval upgrade_pip
  fi
  eval install_pip_dependencies
  eval install_ansible_galaxy_roles
  eval print_execution_time "${start_time}"
}

function provision {
  _echo "$(eval show_version)"
  _echo "Starting time $( date )" 'r'
  eval ask_for_ansible_sudo_password
  eval enable_passwordless_sudo
  eval check_install_path_permissions
  eval install_dependencies
  eval run_ansible_playbook
  eval cleanup_tasks
  _echo "Ending time $( date )" 'r'
  eval print_execution_time "${start_time}"
}

function main {
  verbose='no'
  quiet='no'
  eval set_app_directories
  # Parse options to the `install` command
  case "${1}" in
    -e|--env)
      python_provider="${2}"
      shift 2
      ;;
    --help)
      eval show_usage
      exit 0
      ;;
    --version)
      eval show_version
      exit 0
      ;;
    -*)
      echo "[Error] Invalid option: ${1}" 1>&2
      eval show_usage 1>&2
      exit 1
      ;;
  esac

  action="${1}";
  case "${action}" in
    list)
      action_option=$2; # fetch the action's option
      # Process package options
      _echo "OPTION: ${action_option}"
      case ${action_option} in
        profiles)
          _echo "${profiles_path}" 'r' 1>&2
          _exec "find" "${profiles_path}"  "-maxdepth" "1" "-mindepth" "1" "-type" "directory" "-exec" "basename" "{}" "\\" ";"
          ;;
        '')
          echo "[Error] Missing option for action '${action}'" 1>&2
          eval show_usage 1>&2
          exit 1
          ;;
        *)
          echo "[Error] Incorrect option '${action_option}' for action '${action}'" 1>&2
          eval show_usage 1>&2
          exit 1
          ;;
      esac
      ;;
    # Parse options to the install sub command
    update)
      action_option="${2}";# fetch the action's option
      # Process package options
      verbose='yes' # `update` will always be verbose
      [[ ${quiet} == "no" ]] && eval show_title
      _echo "SPLINTER_CONFIG_DIR: ${SPLINTER_CONFIG_DIR}"
      case ${action_option} in
        deps|dependencies)
          _echo "Will reinstall all the dependencies (Python and Ansible Galaxy roles)" 'w'
          ansible_force_roles_update='--force'
          reinstall_conda='yes'
          reinstall_pyenv='yes'
          eval install_dependencies
          exit 0
          ;;
        conda)
          _echo "Will reinstall the Conda Python environemnt" 'w'
          python_provider="conda"
          reinstall_conda='yes'
          eval install_dependencies
          exit 0
          ;;
        pyenv)
        _echo "Will reinstall the Pyenv Python environemnt" 'w'
          python_provider="pyenv"
          reinstall_pyenv='yes'
          eval install_dependencies
          exit 0
          ;;
        roles|galaxy|ansible)
          _echo "Will reinstall all the Asnible Galaxy roles" 'w'
          ansible_force_roles_update='--force'
          eval install_dependencies
          exit 0
          ;;
        tools)
          _echo "Will update '${my_name}' tools" 'w'
          eval update_tools
          exit 0
          ;;
        self|auto|splinter)
          _echo "Will update '${my_name}'" 'w'
          eval update_splinter
          exit 0
          ;;
        '')
          echo "[Error] Missing option for action '${action}'" 1>&2
          eval show_usage 1>&2
          exit 1
          ;;
        *)
          echo "[Error] Incorrect option '${action_option}' for action '${action}'" 1>&2
          eval show_usage 1>&2
          exit 1
          ;;
      esac
      _echo "OPTION: ${action_option}"
      ;;
    provision )
      shift
      while getopts ":c:b:f:h:p:r:u:qv" action_option; do
        case "${action_option}" in
          c)
            export CUSTOM_CONFIG_FILE="${OPTARG}"
            _echo "CUSTOM_CONFIG_FILE: ${CUSTOM_CONFIG_FILE}"
            ;;
          b)
            if profile_is_available "${OPTARG}" 2>/dev/null ; then
              export SPLINTER_BASE_PROFILE="${OPTARG}"
              _echo "SPLINTER_BASE_PROFILE: ${SPLINTER_BASE_PROFILE}"
            fi
            ;;
          f)
            export NEW_USER_FULL_NAME="${OPTARG}"
            _echo "NEW_USER_FULL_NAME: '${NEW_USER_FULL_NAME}'"
            ;;
          h)
            export COMPUTER_HOST_NAME="${OPTARG}"
            _echo "COMPUTER_HOST_NAME: ${COMPUTER_HOST_NAME}"
            ;;
          p)
            export NEW_USER_PASSWORD_CLEARTEXT="${OPTARG}"
            _echo "NEW_USER_PASSWORD_CLEARTEXT: ${NEW_USER_PASSWORD_CLEARTEXT}"
            ;;
          q)
            [[ ! $verbose == 'yes' ]] && quiet='yes'
            ;;
          r)
            if profile_is_available "${OPTARG}" 2>/dev/null; then
              export SPLINTER_ROLE_PROFILE="${OPTARG}"
              _echo "SPLINTER_ROLE_PROFILE: ${SPLINTER_ROLE_PROFILE}"
            fi
            ;;
          u)
            export NEW_USER_USERNAME="${OPTARG}"
            _echo "NEW_USER_USERNAME: ${NEW_USER_USERNAME}"
            ;;
          v)
            verbose='yes'
            quiet='no'
            ;;
          \?)
            echo "[Error] Action '${action}': Invalid setting '-${OPTARG}'" 1>&2
            eval show_usage 1>&2
            exit 1
            ;;
          :)
            echo "[Error] Action '${action}': setting '-${OPTARG}' is missing an argument" 1>&2
            eval show_usage 1>&2
            exit 1
            ;;
        esac
      done

      shift $(( OPTIND - 1 ))
      if [[ -n "${*}" ]];then
        # if it is NOT empty it means it interrupted before evaluating all the parameters
        # becaue it encountered a unexpected param or arg
        echo "[Error] Provided unknow parameter: ${1}" 1>&2
        eval show_usage 1>&2
        exit 1
      fi

      export VERBOSE="${verbose}"
      [[ ${quiet} == "no" ]] && eval show_title
      _echo "VERBOSE: ${VERBOSE}"
      _echo "SPLINTER_CONFIG_DIR: ${SPLINTER_CONFIG_DIR}"
      eval provision
      ;;
    '')
      echo "[Error] Missing action" 1>&2
      eval show_usage 1>&2
      exit 1
      ;;
    *)
      echo "[Error] Invalid action '$action'" 1>&2
      eval show_usage 1>&2
      exit 1
      ;;
  esac
}
main "${@}"
